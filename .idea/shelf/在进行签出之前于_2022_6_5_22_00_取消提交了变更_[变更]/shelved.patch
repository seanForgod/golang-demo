Index: go.mod
===================================================================
diff --git a/go.mod b/go.mod
deleted file mode 100644
--- a/go.mod	(revision d0d0588ef9358bc4d206356d308b1cf253d00f27)
+++ /dev/null	(revision d0d0588ef9358bc4d206356d308b1cf253d00f27)
@@ -1,5 +0,0 @@
-module golang-demo
-
-go 1.18
-
-require github.com/joho/godotenv v1.4.0
Index: vendor/github.com/joho/godotenv/README.md
===================================================================
diff --git a/vendor/github.com/joho/godotenv/README.md b/vendor/github.com/joho/godotenv/README.md
deleted file mode 100644
--- a/vendor/github.com/joho/godotenv/README.md	(revision d0d0588ef9358bc4d206356d308b1cf253d00f27)
+++ /dev/null	(revision d0d0588ef9358bc4d206356d308b1cf253d00f27)
@@ -1,188 +0,0 @@
-# GoDotEnv ![CI](https://github.com/joho/godotenv/workflows/CI/badge.svg) [![Go Report Card](https://goreportcard.com/badge/github.com/joho/godotenv)](https://goreportcard.com/report/github.com/joho/godotenv)
-
-A Go (golang) port of the Ruby dotenv project (which loads env vars from a .env file)
-
-From the original Library:
-
-> Storing configuration in the environment is one of the tenets of a twelve-factor app. Anything that is likely to change between deployment environments–such as resource handles for databases or credentials for external services–should be extracted from the code into environment variables.
->
-> But it is not always practical to set environment variables on development machines or continuous integration servers where multiple projects are run. Dotenv load variables from a .env file into ENV when the environment is bootstrapped.
-
-It can be used as a library (for loading in env for your own daemons etc) or as a bin command.
-
-There is test coverage and CI for both linuxish and windows environments, but I make no guarantees about the bin version working on windows.
-
-## Installation
-
-As a library
-
-```shell
-go get github.com/joho/godotenv
-```
-
-or if you want to use it as a bin command
-```shell
-go get github.com/joho/godotenv/cmd/godotenv
-```
-
-## Usage
-
-Add your application configuration to your `.env` file in the root of your project:
-
-```shell
-S3_BUCKET=YOURS3BUCKET
-SECRET_KEY=YOURSECRETKEYGOESHERE
-```
-
-Then in your Go app you can do something like
-
-```go
-package main
-
-import (
-    "github.com/joho/godotenv"
-    "log"
-    "os"
-)
-
-func main() {
-  err := godotenv.Load()
-  if err != nil {
-    log.Fatal("Error loading .env file")
-  }
-
-  s3Bucket := os.Getenv("S3_BUCKET")
-  secretKey := os.Getenv("SECRET_KEY")
-
-  // now do something with s3 or whatever
-}
-```
-
-If you're even lazier than that, you can just take advantage of the autoload package which will read in `.env` on import
-
-```go
-import _ "github.com/joho/godotenv/autoload"
-```
-
-While `.env` in the project root is the default, you don't have to be constrained, both examples below are 100% legit
-
-```go
-_ = godotenv.Load("somerandomfile")
-_ = godotenv.Load("filenumberone.env", "filenumbertwo.env")
-```
-
-If you want to be really fancy with your env file you can do comments and exports (below is a valid env file)
-
-```shell
-# I am a comment and that is OK
-SOME_VAR=someval
-FOO=BAR # comments at line end are OK too
-export BAR=BAZ
-```
-
-Or finally you can do YAML(ish) style
-
-```yaml
-FOO: bar
-BAR: baz
-```
-
-as a final aside, if you don't want godotenv munging your env you can just get a map back instead
-
-```go
-var myEnv map[string]string
-myEnv, err := godotenv.Read()
-
-s3Bucket := myEnv["S3_BUCKET"]
-```
-
-... or from an `io.Reader` instead of a local file
-
-```go
-reader := getRemoteFile()
-myEnv, err := godotenv.Parse(reader)
-```
-
-... or from a `string` if you so desire
-
-```go
-content := getRemoteFileContent()
-myEnv, err := godotenv.Unmarshal(content)
-```
-
-### Precedence & Conventions
-
-Existing envs take precedence of envs that are loaded later.
-
-The [convention](https://github.com/bkeepers/dotenv#what-other-env-files-can-i-use)
-for managing multiple environments (i.e. development, test, production)
-is to create an env named `{YOURAPP}_ENV` and load envs in this order:
-
-```go
-env := os.Getenv("FOO_ENV")
-if "" == env {
-  env = "development"
-}
-
-godotenv.Load(".env." + env + ".local")
-if "test" != env {
-  godotenv.Load(".env.local")
-}
-godotenv.Load(".env." + env)
-godotenv.Load() // The Original .env
-```
-
-If you need to, you can also use `godotenv.Overload()` to defy this convention
-and overwrite existing envs instead of only supplanting them. Use with caution.
-
-### Command Mode
-
-Assuming you've installed the command as above and you've got `$GOPATH/bin` in your `$PATH`
-
-```
-godotenv -f /some/path/to/.env some_command with some args
-```
-
-If you don't specify `-f` it will fall back on the default of loading `.env` in `PWD`
-
-### Writing Env Files
-
-Godotenv can also write a map representing the environment to a correctly-formatted and escaped file
-
-```go
-env, err := godotenv.Unmarshal("KEY=value")
-err := godotenv.Write(env, "./.env")
-```
-
-... or to a string
-
-```go
-env, err := godotenv.Unmarshal("KEY=value")
-content, err := godotenv.Marshal(env)
-```
-
-## Contributing
-
-Contributions are most welcome! The parser itself is pretty stupidly naive and I wouldn't be surprised if it breaks with edge cases.
-
-*code changes without tests will not be accepted*
-
-1. Fork it
-2. Create your feature branch (`git checkout -b my-new-feature`)
-3. Commit your changes (`git commit -am 'Added some feature'`)
-4. Push to the branch (`git push origin my-new-feature`)
-5. Create new Pull Request
-
-## Releases
-
-Releases should follow [Semver](http://semver.org/) though the first couple of releases are `v1` and `v1.1`.
-
-Use [annotated tags for all releases](https://github.com/joho/godotenv/issues/30). Example `git tag -a v1.2.1`
-
-## CI
-
-Linux: [![Build Status](https://travis-ci.org/joho/godotenv.svg?branch=master)](https://travis-ci.org/joho/godotenv) Windows: [![Build status](https://ci.appveyor.com/api/projects/status/9v40vnfvvgde64u4)](https://ci.appveyor.com/project/joho/godotenv)
-
-## Who?
-
-The original library [dotenv](https://github.com/bkeepers/dotenv) was written by [Brandon Keepers](http://opensoul.org/), and this port was done by [John Barton](https://johnbarton.co/) based off the tests/fixtures in the original library.
Index: vendor/github.com/joho/godotenv/.gitignore
===================================================================
diff --git a/vendor/github.com/joho/godotenv/.gitignore b/vendor/github.com/joho/godotenv/.gitignore
deleted file mode 100644
--- a/vendor/github.com/joho/godotenv/.gitignore	(revision d0d0588ef9358bc4d206356d308b1cf253d00f27)
+++ /dev/null	(revision d0d0588ef9358bc4d206356d308b1cf253d00f27)
@@ -1,1 +0,0 @@
-.DS_Store
Index: .env
===================================================================
diff --git a/.env b/.env
deleted file mode 100644
--- a/.env	(revision d0d0588ef9358bc4d206356d308b1cf253d00f27)
+++ /dev/null	(revision d0d0588ef9358bc4d206356d308b1cf253d00f27)
@@ -1,1 +0,0 @@
-VERSION=0.0.1
\ No newline at end of file
Index: vendor/modules.txt
===================================================================
diff --git a/vendor/modules.txt b/vendor/modules.txt
deleted file mode 100644
--- a/vendor/modules.txt	(revision d0d0588ef9358bc4d206356d308b1cf253d00f27)
+++ /dev/null	(revision d0d0588ef9358bc4d206356d308b1cf253d00f27)
@@ -1,3 +0,0 @@
-# github.com/joho/godotenv v1.4.0
-## explicit; go 1.12
-github.com/joho/godotenv
Index: vendor/github.com/joho/godotenv/renovate.json
===================================================================
diff --git a/vendor/github.com/joho/godotenv/renovate.json b/vendor/github.com/joho/godotenv/renovate.json
deleted file mode 100644
--- a/vendor/github.com/joho/godotenv/renovate.json	(revision d0d0588ef9358bc4d206356d308b1cf253d00f27)
+++ /dev/null	(revision d0d0588ef9358bc4d206356d308b1cf253d00f27)
@@ -1,5 +0,0 @@
-{
-  "extends": [
-    "config:base"
-  ]
-}
Index: vendor/github.com/joho/godotenv/godotenv.go
===================================================================
diff --git a/vendor/github.com/joho/godotenv/godotenv.go b/vendor/github.com/joho/godotenv/godotenv.go
deleted file mode 100644
--- a/vendor/github.com/joho/godotenv/godotenv.go	(revision d0d0588ef9358bc4d206356d308b1cf253d00f27)
+++ /dev/null	(revision d0d0588ef9358bc4d206356d308b1cf253d00f27)
@@ -1,363 +0,0 @@
-// Package godotenv is a go port of the ruby dotenv library (https://github.com/bkeepers/dotenv)
-//
-// Examples/readme can be found on the github page at https://github.com/joho/godotenv
-//
-// The TL;DR is that you make a .env file that looks something like
-//
-// 		SOME_ENV_VAR=somevalue
-//
-// and then in your go code you can call
-//
-// 		godotenv.Load()
-//
-// and all the env vars declared in .env will be available through os.Getenv("SOME_ENV_VAR")
-package godotenv
-
-import (
-	"bufio"
-	"errors"
-	"fmt"
-	"io"
-	"os"
-	"os/exec"
-	"regexp"
-	"sort"
-	"strconv"
-	"strings"
-)
-
-const doubleQuoteSpecialChars = "\\\n\r\"!$`"
-
-// Load will read your env file(s) and load them into ENV for this process.
-//
-// Call this function as close as possible to the start of your program (ideally in main)
-//
-// If you call Load without any args it will default to loading .env in the current path
-//
-// You can otherwise tell it which files to load (there can be more than one) like
-//
-//		godotenv.Load("fileone", "filetwo")
-//
-// It's important to note that it WILL NOT OVERRIDE an env variable that already exists - consider the .env file to set dev vars or sensible defaults
-func Load(filenames ...string) (err error) {
-	filenames = filenamesOrDefault(filenames)
-
-	for _, filename := range filenames {
-		err = loadFile(filename, false)
-		if err != nil {
-			return // return early on a spazout
-		}
-	}
-	return
-}
-
-// Overload will read your env file(s) and load them into ENV for this process.
-//
-// Call this function as close as possible to the start of your program (ideally in main)
-//
-// If you call Overload without any args it will default to loading .env in the current path
-//
-// You can otherwise tell it which files to load (there can be more than one) like
-//
-//		godotenv.Overload("fileone", "filetwo")
-//
-// It's important to note this WILL OVERRIDE an env variable that already exists - consider the .env file to forcefilly set all vars.
-func Overload(filenames ...string) (err error) {
-	filenames = filenamesOrDefault(filenames)
-
-	for _, filename := range filenames {
-		err = loadFile(filename, true)
-		if err != nil {
-			return // return early on a spazout
-		}
-	}
-	return
-}
-
-// Read all env (with same file loading semantics as Load) but return values as
-// a map rather than automatically writing values into env
-func Read(filenames ...string) (envMap map[string]string, err error) {
-	filenames = filenamesOrDefault(filenames)
-	envMap = make(map[string]string)
-
-	for _, filename := range filenames {
-		individualEnvMap, individualErr := readFile(filename)
-
-		if individualErr != nil {
-			err = individualErr
-			return // return early on a spazout
-		}
-
-		for key, value := range individualEnvMap {
-			envMap[key] = value
-		}
-	}
-
-	return
-}
-
-// Parse reads an env file from io.Reader, returning a map of keys and values.
-func Parse(r io.Reader) (envMap map[string]string, err error) {
-	envMap = make(map[string]string)
-
-	var lines []string
-	scanner := bufio.NewScanner(r)
-	for scanner.Scan() {
-		lines = append(lines, scanner.Text())
-	}
-
-	if err = scanner.Err(); err != nil {
-		return
-	}
-
-	for _, fullLine := range lines {
-		if !isIgnoredLine(fullLine) {
-			var key, value string
-			key, value, err = parseLine(fullLine, envMap)
-
-			if err != nil {
-				return
-			}
-			envMap[key] = value
-		}
-	}
-	return
-}
-
-//Unmarshal reads an env file from a string, returning a map of keys and values.
-func Unmarshal(str string) (envMap map[string]string, err error) {
-	return Parse(strings.NewReader(str))
-}
-
-// Exec loads env vars from the specified filenames (empty map falls back to default)
-// then executes the cmd specified.
-//
-// Simply hooks up os.Stdin/err/out to the command and calls Run()
-//
-// If you want more fine grained control over your command it's recommended
-// that you use `Load()` or `Read()` and the `os/exec` package yourself.
-func Exec(filenames []string, cmd string, cmdArgs []string) error {
-	Load(filenames...)
-
-	command := exec.Command(cmd, cmdArgs...)
-	command.Stdin = os.Stdin
-	command.Stdout = os.Stdout
-	command.Stderr = os.Stderr
-	return command.Run()
-}
-
-// Write serializes the given environment and writes it to a file
-func Write(envMap map[string]string, filename string) error {
-	content, err := Marshal(envMap)
-	if err != nil {
-		return err
-	}
-	file, err := os.Create(filename)
-	if err != nil {
-		return err
-	}
-	defer file.Close()
-	_, err = file.WriteString(content + "\n")
-	if err != nil {
-		return err
-	}
-	file.Sync()
-	return err
-}
-
-// Marshal outputs the given environment as a dotenv-formatted environment file.
-// Each line is in the format: KEY="VALUE" where VALUE is backslash-escaped.
-func Marshal(envMap map[string]string) (string, error) {
-	lines := make([]string, 0, len(envMap))
-	for k, v := range envMap {
-		if d, err := strconv.Atoi(v); err == nil {
-			lines = append(lines, fmt.Sprintf(`%s=%d`, k, d))
-		} else {
-			lines = append(lines, fmt.Sprintf(`%s="%s"`, k, doubleQuoteEscape(v)))
-		}
-	}
-	sort.Strings(lines)
-	return strings.Join(lines, "\n"), nil
-}
-
-func filenamesOrDefault(filenames []string) []string {
-	if len(filenames) == 0 {
-		return []string{".env"}
-	}
-	return filenames
-}
-
-func loadFile(filename string, overload bool) error {
-	envMap, err := readFile(filename)
-	if err != nil {
-		return err
-	}
-
-	currentEnv := map[string]bool{}
-	rawEnv := os.Environ()
-	for _, rawEnvLine := range rawEnv {
-		key := strings.Split(rawEnvLine, "=")[0]
-		currentEnv[key] = true
-	}
-
-	for key, value := range envMap {
-		if !currentEnv[key] || overload {
-			os.Setenv(key, value)
-		}
-	}
-
-	return nil
-}
-
-func readFile(filename string) (envMap map[string]string, err error) {
-	file, err := os.Open(filename)
-	if err != nil {
-		return
-	}
-	defer file.Close()
-
-	return Parse(file)
-}
-
-var exportRegex = regexp.MustCompile(`^\s*(?:export\s+)?(.*?)\s*$`)
-
-func parseLine(line string, envMap map[string]string) (key string, value string, err error) {
-	if len(line) == 0 {
-		err = errors.New("zero length string")
-		return
-	}
-
-	// ditch the comments (but keep quoted hashes)
-	if strings.Contains(line, "#") {
-		segmentsBetweenHashes := strings.Split(line, "#")
-		quotesAreOpen := false
-		var segmentsToKeep []string
-		for _, segment := range segmentsBetweenHashes {
-			if strings.Count(segment, "\"") == 1 || strings.Count(segment, "'") == 1 {
-				if quotesAreOpen {
-					quotesAreOpen = false
-					segmentsToKeep = append(segmentsToKeep, segment)
-				} else {
-					quotesAreOpen = true
-				}
-			}
-
-			if len(segmentsToKeep) == 0 || quotesAreOpen {
-				segmentsToKeep = append(segmentsToKeep, segment)
-			}
-		}
-
-		line = strings.Join(segmentsToKeep, "#")
-	}
-
-	firstEquals := strings.Index(line, "=")
-	firstColon := strings.Index(line, ":")
-	splitString := strings.SplitN(line, "=", 2)
-	if firstColon != -1 && (firstColon < firstEquals || firstEquals == -1) {
-		//this is a yaml-style line
-		splitString = strings.SplitN(line, ":", 2)
-	}
-
-	if len(splitString) != 2 {
-		err = errors.New("Can't separate key from value")
-		return
-	}
-
-	// Parse the key
-	key = splitString[0]
-	if strings.HasPrefix(key, "export") {
-		key = strings.TrimPrefix(key, "export")
-	}
-	key = strings.TrimSpace(key)
-
-	key = exportRegex.ReplaceAllString(splitString[0], "$1")
-
-	// Parse the value
-	value = parseValue(splitString[1], envMap)
-	return
-}
-
-var (
-	singleQuotesRegex  = regexp.MustCompile(`\A'(.*)'\z`)
-	doubleQuotesRegex  = regexp.MustCompile(`\A"(.*)"\z`)
-	escapeRegex        = regexp.MustCompile(`\\.`)
-	unescapeCharsRegex = regexp.MustCompile(`\\([^$])`)
-)
-
-func parseValue(value string, envMap map[string]string) string {
-
-	// trim
-	value = strings.Trim(value, " ")
-
-	// check if we've got quoted values or possible escapes
-	if len(value) > 1 {
-		singleQuotes := singleQuotesRegex.FindStringSubmatch(value)
-
-		doubleQuotes := doubleQuotesRegex.FindStringSubmatch(value)
-
-		if singleQuotes != nil || doubleQuotes != nil {
-			// pull the quotes off the edges
-			value = value[1 : len(value)-1]
-		}
-
-		if doubleQuotes != nil {
-			// expand newlines
-			value = escapeRegex.ReplaceAllStringFunc(value, func(match string) string {
-				c := strings.TrimPrefix(match, `\`)
-				switch c {
-				case "n":
-					return "\n"
-				case "r":
-					return "\r"
-				default:
-					return match
-				}
-			})
-			// unescape characters
-			value = unescapeCharsRegex.ReplaceAllString(value, "$1")
-		}
-
-		if singleQuotes == nil {
-			value = expandVariables(value, envMap)
-		}
-	}
-
-	return value
-}
-
-var expandVarRegex = regexp.MustCompile(`(\\)?(\$)(\()?\{?([A-Z0-9_]+)?\}?`)
-
-func expandVariables(v string, m map[string]string) string {
-	return expandVarRegex.ReplaceAllStringFunc(v, func(s string) string {
-		submatch := expandVarRegex.FindStringSubmatch(s)
-
-		if submatch == nil {
-			return s
-		}
-		if submatch[1] == "\\" || submatch[2] == "(" {
-			return submatch[0][1:]
-		} else if submatch[4] != "" {
-			return m[submatch[4]]
-		}
-		return s
-	})
-}
-
-func isIgnoredLine(line string) bool {
-	trimmedLine := strings.TrimSpace(line)
-	return len(trimmedLine) == 0 || strings.HasPrefix(trimmedLine, "#")
-}
-
-func doubleQuoteEscape(line string) string {
-	for _, c := range doubleQuoteSpecialChars {
-		toReplace := "\\" + string(c)
-		if c == '\n' {
-			toReplace = `\n`
-		}
-		if c == '\r' {
-			toReplace = `\r`
-		}
-		line = strings.Replace(line, string(c), toReplace, -1)
-	}
-	return line
-}
Index: http-server/main.go
===================================================================
diff --git a/http-server/main.go b/http-server/main.go
deleted file mode 100644
--- a/http-server/main.go	(revision d0d0588ef9358bc4d206356d308b1cf253d00f27)
+++ /dev/null	(revision d0d0588ef9358bc4d206356d308b1cf253d00f27)
@@ -1,76 +0,0 @@
-package main
-
-import (
-	"github.com/joho/godotenv"
-	"io"
-	"log"
-	"net"
-	"net/http"
-	"os"
-	"strings"
-)
-
-func main() {
-	http.HandleFunc("/", commonHandler)
-	log.Fatal(http.ListenAndServe("localhost:80", nil))
-}
-
-// common request handler
-func commonHandler(writer http.ResponseWriter, request *http.Request) {
-	var statusCode = 0
-	var responseStr = ""
-
-	if request.URL.Path == "/healthz" {
-		statusCode = 200
-		responseStr = "the server is ok"
-	} else {
-		statusCode = 404
-		responseStr = "the path is not exist"
-	}
-	//打印请求ip
-	printClientIpAndResponseStatus(request, statusCode)
-	//将请求头add到返回头中
-	requestHeaderAddResponseHeader(writer, request)
-	//将环境变量add到response header中
-	addEvnVariableToResponseHeader(writer)
-	//设置请求返回码
-	writer.WriteHeader(statusCode)
-	//设置请求返回参数
-	io.WriteString(writer, responseStr)
-}
-
-// add environment variable to response header
-func addEvnVariableToResponseHeader(writer http.ResponseWriter) {
-	godotenv.Load()
-	version := os.Getenv("VERSION")
-	log.Printf("the local ststem var, VERSION: [%s]", version)
-	writer.Header().Set("VERSION", version)
-}
-
-// print client ip, request path and  response status code
-func printClientIpAndResponseStatus(request *http.Request, statusCode int) {
-	log.Printf("request client ip :[%s],request path: [%s], response status code : [%d]", GetClientIp(request), request.URL.Path, statusCode)
-}
-
-// request header add response header
-func requestHeaderAddResponseHeader(writer http.ResponseWriter, request *http.Request) {
-	for k := range request.Header {
-		value := request.Header.Get(k)
-		writer.Header().Set(k, value)
-	}
-}
-
-// GetClientIp /**
-func GetClientIp(request *http.Request) string {
-	ip := request.Header.Get("X-Real-IP")
-	if net.ParseIP(ip) != nil {
-		return ip
-	}
-	ip = request.Header.Get("X-Forward-For")
-	for _, i := range strings.Split(ip, ",") {
-		if net.ParseIP(i) != nil {
-			return i
-		}
-	}
-	return strings.Split(request.RemoteAddr, ":")[0]
-}
Index: src/http-server/main.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/http-server/main.go b/src/http-server/main.go
new file mode 100644
--- /dev/null	(date 1654434203528)
+++ b/src/http-server/main.go	(date 1654434203528)
@@ -0,0 +1,75 @@
+package main
+
+import (
+	"io"
+	"log"
+	"net"
+	"net/http"
+	"os"
+	"strings"
+)
+
+func main() {
+	http.HandleFunc("/", commonHandler)
+	log.Fatal(http.ListenAndServe("localhost:80", nil))
+}
+
+// common request handler
+func commonHandler(writer http.ResponseWriter, request *http.Request) {
+	var statusCode = 0
+	var responseStr = ""
+
+	if request.URL.Path == "/healthz" {
+		statusCode = 200
+		responseStr = "the server is ok"
+	} else {
+		statusCode = 404
+		responseStr = "the path is not exist"
+	}
+	//打印请求ip
+	printClientIpAndResponseStatus(request, statusCode)
+	//将请求头add到返回头中
+	requestHeaderAddResponseHeader(writer, request)
+	//将环境变量add到response header中
+	addEvnVariableToResponseHeader(writer)
+	//设置请求返回码
+	writer.WriteHeader(statusCode)
+	//设置请求返回参数
+	io.WriteString(writer, responseStr)
+}
+
+// add environment variable to response header
+func addEvnVariableToResponseHeader(writer http.ResponseWriter) {
+	os.Setenv("VERSION","0.0.1")
+	version := os.Getenv("VERSION")
+	log.Printf("the local ststem var, VERSION: [%s]", version)
+	writer.Header().Set("VERSION", version)
+}
+
+// print client ip, request path and  response status code
+func printClientIpAndResponseStatus(request *http.Request, statusCode int) {
+	log.Printf("request client ip :[%s],request path: [%s], response status code : [%d]", getClientIp(request), request.URL.Path, statusCode)
+}
+
+// request header add response header
+func requestHeaderAddResponseHeader(writer http.ResponseWriter, request *http.Request) {
+	for k := range request.Header {
+		value := request.Header.Get(k)
+		writer.Header().Set(k, value)
+	}
+}
+
+// GetClientIp /**
+func getClientIp(request *http.Request) string {
+	ip := request.Header.Get("X-Real-IP")
+	if net.ParseIP(ip) != nil {
+		return ip
+	}
+	ip = request.Header.Get("X-Forward-For")
+	for _, i := range strings.Split(ip, ",") {
+		if net.ParseIP(i) != nil {
+			return i
+		}
+	}
+	return strings.Split(request.RemoteAddr, ":")[0]
+}
